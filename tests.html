<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monte Carlo Simulator - Test Suite</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0e17;
            color: #e5e7eb;
            padding: 20px;
            line-height: 1.6;
        }
        h1 {
            color: #10b981;
            margin-bottom: 20px;
            border-bottom: 2px solid #10b981;
            padding-bottom: 10px;
        }
        h2 {
            color: #3b82f6;
            margin: 25px 0 15px;
            font-size: 1.2em;
        }
        .test-suite {
            background: #111827;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .test-result {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: 13px;
        }
        .pass {
            background: rgba(16, 185, 129, 0.15);
            border-left: 3px solid #10b981;
            color: #10b981;
        }
        .fail {
            background: rgba(239, 68, 68, 0.15);
            border-left: 3px solid #ef4444;
            color: #ef4444;
        }
        .summary {
            background: #1a2234;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        .summary-item {
            text-align: center;
        }
        .summary-number {
            font-size: 2em;
            font-weight: bold;
            font-family: 'JetBrains Mono', monospace;
        }
        .summary-label {
            color: #9ca3af;
            font-size: 0.9em;
        }
        .pass-rate {
            color: #10b981;
        }
        .fail-count {
            color: #ef4444;
        }
        .total-count {
            color: #3b82f6;
        }
        .error-details {
            margin-top: 5px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            font-size: 12px;
            color: #f87171;
            white-space: pre-wrap;
        }
        .run-button {
            background: #10b981;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        .run-button:hover {
            background: #059669;
        }
        .run-button:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }
        .progress {
            color: #9ca3af;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>ðŸ§ª Monte Carlo Simulator - Test Suite</h1>
    <button class="run-button" onclick="runAllTests()">Run All Tests</button>
    <div id="progress" class="progress"></div>
    <div id="results"></div>
    <div id="summary" class="summary" style="display: none;"></div>

    <script>
        // ============================================
        // MINIMAL TEST FRAMEWORK (Zero Dependencies)
        // ============================================

        class TestFramework {
            constructor() {
                this.tests = [];
                this.results = [];
                this.currentSuite = null;
            }

            describe(suiteName, fn) {
                this.currentSuite = suiteName;
                fn();
                this.currentSuite = null;
            }

            it(testName, fn) {
                this.tests.push({
                    suite: this.currentSuite,
                    name: testName,
                    fn
                });
            }

            async runAll(progressCallback) {
                this.results = [];
                for (let i = 0; i < this.tests.length; i++) {
                    const test = this.tests[i];
                    progressCallback(`Running: ${test.suite} - ${test.name} (${i + 1}/${this.tests.length})`);

                    try {
                        await test.fn();
                        this.results.push({ ...test, passed: true });
                    } catch (error) {
                        this.results.push({ ...test, passed: false, error: error.message });
                    }

                    // Small delay to allow UI updates
                    await new Promise(r => setTimeout(r, 1));
                }
                return this.results;
            }

            getResultsBySuite() {
                const suites = {};
                for (const result of this.results) {
                    if (!suites[result.suite]) {
                        suites[result.suite] = [];
                    }
                    suites[result.suite].push(result);
                }
                return suites;
            }

            getSummary() {
                const total = this.results.length;
                const passed = this.results.filter(r => r.passed).length;
                const failed = total - passed;
                return { total, passed, failed, rate: ((passed / total) * 100).toFixed(1) };
            }
        }

        // Assertion helpers
        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(message || `Expected ${expected}, got ${actual}`);
            }
        }

        function assertAlmostEqual(actual, expected, tolerance = 0.001, message) {
            if (Math.abs(actual - expected) > tolerance) {
                throw new Error(message || `Expected ~${expected}, got ${actual} (tolerance: ${tolerance})`);
            }
        }

        function assertInRange(value, min, max, message) {
            if (value < min || value > max) {
                throw new Error(message || `Expected ${value} to be in range [${min}, ${max}]`);
            }
        }

        function assertGreaterThan(actual, expected, message) {
            if (actual <= expected) {
                throw new Error(message || `Expected ${actual} > ${expected}`);
            }
        }

        function assertLessThan(actual, expected, message) {
            if (actual >= expected) {
                throw new Error(message || `Expected ${actual} < ${expected}`);
            }
        }

        // ============================================
        // SEEDED PSEUDO-RANDOM NUMBER GENERATOR
        // Mulberry32: Fast, simple, seedable 32-bit PRNG
        // ============================================
        class SeededRNG {
            constructor(seed) {
                this.state = seed >>> 0;
            }

            next() {
                let t = this.state += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            getState() {
                return this.state;
            }
        }

        // ============================================
        // MONTE CARLO ENGINE (Copied for testing)
        // ============================================

        class MonteCarloEngine {
            constructor(params) {
                this.params = params;
                const seed = params.seed !== undefined ? params.seed : Math.floor(Math.random() * 2147483647);
                this.rng = new SeededRNG(seed);
                this.initialSeed = seed;
            }

            getSeed() {
                return this.initialSeed;
            }

            random() {
                return this.rng.next();
            }

            // Box-Muller transform for normal distribution
            randomNormal(mean = 0, std = 1) {
                const u1 = this.random();
                const u2 = this.random();
                const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
                return z0 * std + mean;
            }

            // Generate random number from Student's T distribution (fatter tails)
            randomStudentT(mean, std, df) {
                const z = this.randomNormal(0, 1);
                let chiSquared = 0;
                for (let i = 0; i < df; i++) {
                    const n = this.randomNormal(0, 1);
                    chiSquared += n * n;
                }
                const scaleFactor = df > 2 ? Math.sqrt((df - 2) / df) : 1;
                const t = z / Math.sqrt(chiSquared / df) * scaleFactor;
                return mean + std * t;
            }

            generateReturn(mean, std) {
                if (this.params.useStudentT) {
                    return this.randomStudentT(mean, std, this.params.degreesOfFreedom);
                }
                return this.randomNormal(mean, std);
            }

            generateIPCA(equityReturn) {
                if (!this.params.useIPCAModel) {
                    return this.params.inflation / 100;
                }
                const baseIPCA = this.params.expectedIPCA / 100;
                const ipcaVol = this.params.ipcaVolatility / 100;
                const equityMean = this.params.equityReturn / 100;
                const equityVol = this.params.equityVolatility / 100;
                const correlatedShock = -0.2 * (equityReturn - equityMean) / equityVol;
                const randomShock = this.randomNormal(0, ipcaVol);
                const ipca = Math.max(0, Math.min(0.15, baseIPCA + correlatedShock * ipcaVol + randomShock));
                return ipca;
            }

            generateBondReturn(ipca) {
                if (!this.params.useIPCAModel) {
                    return this.generateReturn(this.params.bondReturn / 100, this.params.bondVolatility / 100);
                }
                const realSpread = this.params.realSpread / 100;
                const spreadVariation = this.randomNormal(0, 0.005);
                return ipca + realSpread + spreadVariation;
            }

            getDynamicCorrelation(equityReturn) {
                if (!this.params.useDynamicCorrelation) {
                    return this.params.baseCorrelation;
                }
                const baseCorr = this.params.baseCorrelation;
                const stressMult = this.params.stressCorrelationMultiplier;
                const equityMean = this.params.equityReturn / 100;
                const equityVol = this.params.equityVolatility / 100;
                const zScore = (equityReturn - equityMean) / equityVol;

                if (zScore < -1) {
                    const stressFactor = Math.min(Math.abs(zScore) - 1, 2) / 2;
                    return Math.max(-0.9, baseCorr * (1 + stressFactor * (stressMult - 1)));
                } else if (zScore > 1) {
                    const boomFactor = Math.min(zScore - 1, 2) / 2;
                    return baseCorr * (1 - boomFactor * 0.5);
                }
                return baseCorr;
            }

            calculateTax(withdrawalUSD, gainRatio, bondAllocation) {
                if (!this.params.useTaxModel) {
                    return 0;
                }
                const equityWithdrawal = withdrawalUSD * (1 - bondAllocation);
                const bondWithdrawal = withdrawalUSD * bondAllocation;
                const equityTax = equityWithdrawal * gainRatio * (this.params.equityTaxRate / 100);
                const bondTax = bondWithdrawal * gainRatio * (this.params.fixedIncomeTaxRate / 100);
                return equityTax + bondTax;
            }

            generateCorrelatedReturns(correlation) {
                const z1 = this.randomNormal();
                const z2 = this.randomNormal();
                const correlatedZ2 = correlation * z1 + Math.sqrt(1 - correlation * correlation) * z2;
                return [z1, correlatedZ2];
            }

            simulateCurrency(equityReturn, baseFX, volatilityFX = 0.15) {
                const correlation = this.getDynamicCorrelation(equityReturn);
                const [_, fxShock] = this.generateCorrelatedReturns(correlation);
                const meanFX = this.params.initialFX;
                const reversionSpeed = 0.1;
                const drift = reversionSpeed * (meanFX - baseFX) / meanFX;
                const stressMultiplier = equityReturn < 0 ? 1.3 : 1.0;
                const fxReturn = drift + fxShock * volatilityFX * stressMultiplier;
                return baseFX * (1 + fxReturn);
            }

            applyGuytonKlinger(currentWithdrawal, portfolioValue, initialWithdrawalRate, previousReturn, inflation) {
                const currentRate = currentWithdrawal / portfolioValue;
                const { preservationThreshold, prosperityThreshold, adjustmentPercent, applyInflationRule } = this.params;

                let newWithdrawal = currentWithdrawal;
                let ruleApplied = null;

                if (applyInflationRule && previousReturn < 0) {
                    ruleApplied = 'inflation_skip';
                } else {
                    newWithdrawal *= (1 + inflation);
                }

                // Mutual exclusivity: only one of preservation OR prosperity can apply per year
                if (currentRate > initialWithdrawalRate * (1 + preservationThreshold)) {
                    newWithdrawal *= (1 - adjustmentPercent);
                    ruleApplied = 'preservation';
                } else if (currentRate < initialWithdrawalRate * (1 - prosperityThreshold)) {
                    newWithdrawal *= (1 + adjustmentPercent);
                    ruleApplied = 'prosperity';
                }

                return { withdrawal: newWithdrawal, ruleApplied };
            }
        }

        // ============================================
        // TEST DEFINITIONS
        // ============================================

        const tf = new TestFramework();

        // Default test params
        function getDefaultParams() {
            return {
                initialPortfolioUSD: 1000000,
                initialPortfolioBRL: 0,
                initialFX: 5.5,
                withdrawalRate: 4.7,
                equityReturn: 7,
                equityVolatility: 18,
                bondReturn: 4,
                bondVolatility: 6,
                inflation: 4.5,
                years: 30,
                useStudentT: false,
                degreesOfFreedom: 5,
                useIPCAModel: false,
                expectedIPCA: 4.5,
                ipcaVolatility: 1.5,
                realSpread: 5.5,
                useDynamicCorrelation: false,
                baseCorrelation: -0.4,
                stressCorrelationMultiplier: 2.0,
                useTaxModel: false,
                equityTaxRate: 15,
                fixedIncomeTaxRate: 15,
                preservationThreshold: 0.2,
                prosperityThreshold: 0.2,
                adjustmentPercent: 0.1,
                applyInflationRule: true,
                useBucketStrategy: false,
                bucketYears: 5,
                tentInitialBondPercent: 40,
                tentDuration: 5,
                targetBondPercent: 30,
                useMinimumWithdrawal: false,
                minimumWithdrawalBRL: 0,
                maxNegativeSequence: 10
            };
        }

        // ============================================
        // 1. STATISTICAL DISTRIBUTION VALIDATION
        // ============================================

        tf.describe('Box-Muller Normal Distribution', () => {
            tf.it('should generate values with mean approximately 0', () => {
                const engine = new MonteCarloEngine(getDefaultParams());
                const samples = [];
                for (let i = 0; i < 10000; i++) {
                    samples.push(engine.randomNormal(0, 1));
                }
                const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
                assertAlmostEqual(mean, 0, 0.05, `Mean should be ~0, got ${mean}`);
            });

            tf.it('should generate values with standard deviation approximately 1', () => {
                const engine = new MonteCarloEngine(getDefaultParams());
                const samples = [];
                for (let i = 0; i < 10000; i++) {
                    samples.push(engine.randomNormal(0, 1));
                }
                const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
                const variance = samples.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / samples.length;
                const std = Math.sqrt(variance);
                assertAlmostEqual(std, 1, 0.05, `StdDev should be ~1, got ${std}`);
            });

            tf.it('should correctly apply custom mean and standard deviation', () => {
                const engine = new MonteCarloEngine(getDefaultParams());
                const targetMean = 0.07;
                const targetStd = 0.18;
                const samples = [];
                for (let i = 0; i < 10000; i++) {
                    samples.push(engine.randomNormal(targetMean, targetStd));
                }
                const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
                const variance = samples.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / samples.length;
                const std = Math.sqrt(variance);
                assertAlmostEqual(mean, targetMean, 0.01, `Mean should be ~${targetMean}, got ${mean}`);
                assertAlmostEqual(std, targetStd, 0.02, `StdDev should be ~${targetStd}, got ${std}`);
            });

            tf.it('should produce approximately 68% of values within 1 std dev', () => {
                const engine = new MonteCarloEngine(getDefaultParams());
                const samples = [];
                for (let i = 0; i < 10000; i++) {
                    samples.push(engine.randomNormal(0, 1));
                }
                const withinOneStd = samples.filter(x => Math.abs(x) <= 1).length;
                const percentage = withinOneStd / samples.length;
                assertInRange(percentage, 0.65, 0.71, `~68% should be within 1 std, got ${(percentage * 100).toFixed(1)}%`);
            });

            tf.it('should produce approximately 95% of values within 2 std dev', () => {
                const engine = new MonteCarloEngine(getDefaultParams());
                const samples = [];
                for (let i = 0; i < 10000; i++) {
                    samples.push(engine.randomNormal(0, 1));
                }
                const withinTwoStd = samples.filter(x => Math.abs(x) <= 2).length;
                const percentage = withinTwoStd / samples.length;
                assertInRange(percentage, 0.93, 0.97, `~95% should be within 2 std, got ${(percentage * 100).toFixed(1)}%`);
            });
        });

        tf.describe('Student-T Distribution (Fat Tails)', () => {
            tf.it('should generate values with approximately correct mean', () => {
                const params = { ...getDefaultParams(), useStudentT: true, degreesOfFreedom: 5 };
                const engine = new MonteCarloEngine(params);
                const samples = [];
                for (let i = 0; i < 10000; i++) {
                    samples.push(engine.randomStudentT(0.07, 0.18, 5));
                }
                const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
                assertAlmostEqual(mean, 0.07, 0.02, `Mean should be ~0.07, got ${mean}`);
            });

            tf.it('should have fatter tails than normal distribution', () => {
                const engine = new MonteCarloEngine(getDefaultParams());

                // Generate normal samples
                const normalSamples = [];
                for (let i = 0; i < 20000; i++) {
                    normalSamples.push(engine.randomNormal(0, 1));
                }

                // Generate T-Student samples
                const tSamples = [];
                for (let i = 0; i < 20000; i++) {
                    tSamples.push(engine.randomStudentT(0, 1, 5));
                }

                // Count extreme values (beyond 3 std dev)
                const normalExtremes = normalSamples.filter(x => Math.abs(x) > 3).length;
                const tExtremes = tSamples.filter(x => Math.abs(x) > 3).length;

                assertGreaterThan(tExtremes, normalExtremes,
                    `T-distribution should have more extreme values: T=${tExtremes}, Normal=${normalExtremes}`);
            });

            tf.it('should maintain approximately correct standard deviation after scaling', () => {
                const params = { ...getDefaultParams(), useStudentT: true, degreesOfFreedom: 5 };
                const engine = new MonteCarloEngine(params);
                const targetStd = 0.18;
                const samples = [];
                for (let i = 0; i < 10000; i++) {
                    samples.push(engine.randomStudentT(0, targetStd, 5));
                }
                const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
                const variance = samples.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / samples.length;
                const std = Math.sqrt(variance);
                // T-distribution std may vary more, use larger tolerance
                assertInRange(std, targetStd * 0.8, targetStd * 1.3, `StdDev should be ~${targetStd}, got ${std}`);
            });
        });

        tf.describe('Cholesky Correlation', () => {
            tf.it('should generate uncorrelated variables when correlation is 0', () => {
                const engine = new MonteCarloEngine(getDefaultParams());
                const samples = [];
                for (let i = 0; i < 5000; i++) {
                    samples.push(engine.generateCorrelatedReturns(0));
                }

                // Calculate sample correlation
                const z1s = samples.map(s => s[0]);
                const z2s = samples.map(s => s[1]);
                const mean1 = z1s.reduce((a, b) => a + b, 0) / z1s.length;
                const mean2 = z2s.reduce((a, b) => a + b, 0) / z2s.length;

                let cov = 0, var1 = 0, var2 = 0;
                for (let i = 0; i < samples.length; i++) {
                    const d1 = z1s[i] - mean1;
                    const d2 = z2s[i] - mean2;
                    cov += d1 * d2;
                    var1 += d1 * d1;
                    var2 += d2 * d2;
                }
                const correlation = cov / Math.sqrt(var1 * var2);

                assertAlmostEqual(correlation, 0, 0.1, `Correlation should be ~0, got ${correlation.toFixed(3)}`);
            });

            tf.it('should generate positively correlated variables when correlation > 0', () => {
                const engine = new MonteCarloEngine(getDefaultParams());
                const targetCorr = 0.7;
                const samples = [];
                for (let i = 0; i < 5000; i++) {
                    samples.push(engine.generateCorrelatedReturns(targetCorr));
                }

                const z1s = samples.map(s => s[0]);
                const z2s = samples.map(s => s[1]);
                const mean1 = z1s.reduce((a, b) => a + b, 0) / z1s.length;
                const mean2 = z2s.reduce((a, b) => a + b, 0) / z2s.length;

                let cov = 0, var1 = 0, var2 = 0;
                for (let i = 0; i < samples.length; i++) {
                    const d1 = z1s[i] - mean1;
                    const d2 = z2s[i] - mean2;
                    cov += d1 * d2;
                    var1 += d1 * d1;
                    var2 += d2 * d2;
                }
                const correlation = cov / Math.sqrt(var1 * var2);

                assertAlmostEqual(correlation, targetCorr, 0.1,
                    `Correlation should be ~${targetCorr}, got ${correlation.toFixed(3)}`);
            });

            tf.it('should generate negatively correlated variables when correlation < 0', () => {
                const engine = new MonteCarloEngine(getDefaultParams());
                const targetCorr = -0.4;
                const samples = [];
                for (let i = 0; i < 5000; i++) {
                    samples.push(engine.generateCorrelatedReturns(targetCorr));
                }

                const z1s = samples.map(s => s[0]);
                const z2s = samples.map(s => s[1]);
                const mean1 = z1s.reduce((a, b) => a + b, 0) / z1s.length;
                const mean2 = z2s.reduce((a, b) => a + b, 0) / z2s.length;

                let cov = 0, var1 = 0, var2 = 0;
                for (let i = 0; i < samples.length; i++) {
                    const d1 = z1s[i] - mean1;
                    const d2 = z2s[i] - mean2;
                    cov += d1 * d2;
                    var1 += d1 * d1;
                    var2 += d2 * d2;
                }
                const correlation = cov / Math.sqrt(var1 * var2);

                assertAlmostEqual(correlation, targetCorr, 0.1,
                    `Correlation should be ~${targetCorr}, got ${correlation.toFixed(3)}`);
            });
        });

        // ============================================
        // 2. GUYTON-KLINGER RULES
        // ============================================

        tf.describe('Guyton-Klinger: Preservation Rule', () => {
            tf.it('should trigger preservation rule when withdrawal rate exceeds threshold', () => {
                const params = {
                    ...getDefaultParams(),
                    preservationThreshold: 0.2,
                    prosperityThreshold: 0.2,
                    adjustmentPercent: 0.1,
                    applyInflationRule: false
                };
                const engine = new MonteCarloEngine(params);

                // Initial rate = 4.7%, portfolio dropped so current rate = 6% (>4.7*1.2=5.64%)
                const currentWithdrawal = 60000;
                const portfolioValue = 1000000;  // 6% rate
                const initialRate = 0.047;

                const result = engine.applyGuytonKlinger(currentWithdrawal, portfolioValue, initialRate, 0.05, 0);

                assertEqual(result.ruleApplied, 'preservation', 'Preservation rule should be applied');
                assertAlmostEqual(result.withdrawal, currentWithdrawal * 0.9, 0.01,
                    'Withdrawal should be reduced by 10%');
            });

            tf.it('should NOT trigger preservation rule when rate is below threshold', () => {
                const params = {
                    ...getDefaultParams(),
                    preservationThreshold: 0.2,
                    prosperityThreshold: 0.2,
                    adjustmentPercent: 0.1,
                    applyInflationRule: false
                };
                const engine = new MonteCarloEngine(params);

                // Current rate = 5% which is < 5.64% threshold
                const currentWithdrawal = 50000;
                const portfolioValue = 1000000;  // 5% rate
                const initialRate = 0.047;

                const result = engine.applyGuytonKlinger(currentWithdrawal, portfolioValue, initialRate, 0.05, 0);

                assert(result.ruleApplied !== 'preservation', 'Preservation rule should NOT be applied');
            });
        });

        tf.describe('Guyton-Klinger: Prosperity Rule', () => {
            tf.it('should trigger prosperity rule when withdrawal rate is below threshold', () => {
                const params = {
                    ...getDefaultParams(),
                    preservationThreshold: 0.2,
                    prosperityThreshold: 0.2,
                    adjustmentPercent: 0.1,
                    applyInflationRule: false
                };
                const engine = new MonteCarloEngine(params);

                // Initial rate = 4.7%, portfolio grew so current rate = 3% (<4.7*0.8=3.76%)
                const currentWithdrawal = 30000;
                const portfolioValue = 1000000;  // 3% rate
                const initialRate = 0.047;

                const result = engine.applyGuytonKlinger(currentWithdrawal, portfolioValue, initialRate, 0.05, 0);

                assertEqual(result.ruleApplied, 'prosperity', 'Prosperity rule should be applied');
                assertAlmostEqual(result.withdrawal, currentWithdrawal * 1.1, 0.01,
                    'Withdrawal should be increased by 10%');
            });

            tf.it('should NOT trigger prosperity rule when rate is above threshold', () => {
                const params = {
                    ...getDefaultParams(),
                    preservationThreshold: 0.2,
                    prosperityThreshold: 0.2,
                    adjustmentPercent: 0.1,
                    applyInflationRule: false
                };
                const engine = new MonteCarloEngine(params);

                // Current rate = 4% which is > 3.76% threshold
                const currentWithdrawal = 40000;
                const portfolioValue = 1000000;  // 4% rate
                const initialRate = 0.047;

                const result = engine.applyGuytonKlinger(currentWithdrawal, portfolioValue, initialRate, 0.05, 0);

                assert(result.ruleApplied !== 'prosperity', 'Prosperity rule should NOT be applied');
            });
        });

        tf.describe('Guyton-Klinger: Inflation Rule', () => {
            tf.it('should skip inflation adjustment after negative return year', () => {
                const params = {
                    ...getDefaultParams(),
                    preservationThreshold: 0.2,
                    prosperityThreshold: 0.2,
                    adjustmentPercent: 0.1,
                    applyInflationRule: true
                };
                const engine = new MonteCarloEngine(params);

                const currentWithdrawal = 47000;
                const portfolioValue = 1000000;
                const initialRate = 0.047;
                const previousReturn = -0.10;  // Negative return
                const inflation = 0.045;

                const result = engine.applyGuytonKlinger(currentWithdrawal, portfolioValue, initialRate, previousReturn, inflation);

                assertEqual(result.ruleApplied, 'inflation_skip', 'Inflation skip rule should be applied');
                assertEqual(result.withdrawal, currentWithdrawal, 'Withdrawal should NOT be adjusted for inflation');
            });

            tf.it('should apply inflation adjustment after positive return year', () => {
                const params = {
                    ...getDefaultParams(),
                    preservationThreshold: 0.2,
                    prosperityThreshold: 0.2,
                    adjustmentPercent: 0.1,
                    applyInflationRule: true
                };
                const engine = new MonteCarloEngine(params);

                const currentWithdrawal = 47000;
                const portfolioValue = 1000000;
                const initialRate = 0.047;
                const previousReturn = 0.08;  // Positive return
                const inflation = 0.045;

                const result = engine.applyGuytonKlinger(currentWithdrawal, portfolioValue, initialRate, previousReturn, inflation);

                assert(result.ruleApplied !== 'inflation_skip', 'Inflation should be applied');
                assertAlmostEqual(result.withdrawal, currentWithdrawal * (1 + inflation), 1,
                    'Withdrawal should be adjusted for inflation');
            });
        });

        // ============================================
        // 3. TAX CALCULATIONS
        // ============================================

        tf.describe('Tax Calculations', () => {
            tf.it('should return 0 tax when tax model is disabled', () => {
                const params = { ...getDefaultParams(), useTaxModel: false };
                const engine = new MonteCarloEngine(params);

                const tax = engine.calculateTax(100000, 0.6, 0.4);
                assertEqual(tax, 0, 'Tax should be 0 when disabled');
            });

            tf.it('should calculate tax correctly for 100% equity allocation', () => {
                const params = {
                    ...getDefaultParams(),
                    useTaxModel: true,
                    equityTaxRate: 15,
                    fixedIncomeTaxRate: 15
                };
                const engine = new MonteCarloEngine(params);

                const withdrawalUSD = 100000;
                const gainRatio = 0.6;  // 60% gains
                const bondAllocation = 0;  // 100% equity

                const tax = engine.calculateTax(withdrawalUSD, gainRatio, bondAllocation);
                const expectedTax = 100000 * 0.6 * 0.15;  // 100% equity * 60% gains * 15% tax

                assertAlmostEqual(tax, expectedTax, 0.01, `Tax should be ${expectedTax}, got ${tax}`);
            });

            tf.it('should calculate tax correctly for 100% bond allocation', () => {
                const params = {
                    ...getDefaultParams(),
                    useTaxModel: true,
                    equityTaxRate: 15,
                    fixedIncomeTaxRate: 15
                };
                const engine = new MonteCarloEngine(params);

                const withdrawalUSD = 100000;
                const gainRatio = 0.6;
                const bondAllocation = 1;  // 100% bonds

                const tax = engine.calculateTax(withdrawalUSD, gainRatio, bondAllocation);
                const expectedTax = 100000 * 0.6 * 0.15;  // 100% bonds * 60% gains * 15% tax

                assertAlmostEqual(tax, expectedTax, 0.01, `Tax should be ${expectedTax}, got ${tax}`);
            });

            tf.it('should calculate tax correctly for mixed allocation', () => {
                const params = {
                    ...getDefaultParams(),
                    useTaxModel: true,
                    equityTaxRate: 15,
                    fixedIncomeTaxRate: 15
                };
                const engine = new MonteCarloEngine(params);

                const withdrawalUSD = 100000;
                const gainRatio = 0.6;
                const bondAllocation = 0.4;  // 40% bonds, 60% equity

                const tax = engine.calculateTax(withdrawalUSD, gainRatio, bondAllocation);
                const equityTax = 60000 * 0.6 * 0.15;
                const bondTax = 40000 * 0.6 * 0.15;
                const expectedTax = equityTax + bondTax;

                assertAlmostEqual(tax, expectedTax, 0.01, `Tax should be ${expectedTax}, got ${tax}`);
            });

            tf.it('should handle different tax rates for equity and bonds', () => {
                const params = {
                    ...getDefaultParams(),
                    useTaxModel: true,
                    equityTaxRate: 15,
                    fixedIncomeTaxRate: 22.5
                };
                const engine = new MonteCarloEngine(params);

                const withdrawalUSD = 100000;
                const gainRatio = 0.5;
                const bondAllocation = 0.5;

                const tax = engine.calculateTax(withdrawalUSD, gainRatio, bondAllocation);
                const equityTax = 50000 * 0.5 * 0.15;
                const bondTax = 50000 * 0.5 * 0.225;
                const expectedTax = equityTax + bondTax;

                assertAlmostEqual(tax, expectedTax, 0.01, `Tax should be ${expectedTax}, got ${tax}`);
            });
        });

        // ============================================
        // 4. IPCA MODEL
        // ============================================

        tf.describe('IPCA Model', () => {
            tf.it('should return fixed inflation when IPCA model is disabled', () => {
                const params = {
                    ...getDefaultParams(),
                    useIPCAModel: false,
                    inflation: 4.5
                };
                const engine = new MonteCarloEngine(params);

                const ipca = engine.generateIPCA(0.07);
                assertEqual(ipca, 0.045, 'IPCA should equal fixed inflation rate');
            });

            tf.it('should generate IPCA within bounds (0% to 15%)', () => {
                const params = {
                    ...getDefaultParams(),
                    useIPCAModel: true,
                    expectedIPCA: 4.5,
                    ipcaVolatility: 1.5,
                    equityReturn: 7,
                    equityVolatility: 18
                };
                const engine = new MonteCarloEngine(params);

                for (let i = 0; i < 1000; i++) {
                    const equityReturn = engine.randomNormal(0.07, 0.18);
                    const ipca = engine.generateIPCA(equityReturn);
                    assertInRange(ipca, 0, 0.15, `IPCA ${ipca} should be in range [0, 0.15]`);
                }
            });

            tf.it('should have negative correlation with equity returns (higher IPCA during stress)', () => {
                const params = {
                    ...getDefaultParams(),
                    useIPCAModel: true,
                    expectedIPCA: 4.5,
                    ipcaVolatility: 1.5,
                    equityReturn: 7,
                    equityVolatility: 18
                };
                const engine = new MonteCarloEngine(params);

                // Collect IPCA for very negative vs very positive equity returns
                const negativeReturns = [];
                const positiveReturns = [];

                for (let i = 0; i < 1000; i++) {
                    negativeReturns.push(engine.generateIPCA(-0.30));  // -30% crash
                    positiveReturns.push(engine.generateIPCA(0.30));   // +30% boom
                }

                const avgNegative = negativeReturns.reduce((a, b) => a + b, 0) / negativeReturns.length;
                const avgPositive = positiveReturns.reduce((a, b) => a + b, 0) / positiveReturns.length;

                assertGreaterThan(avgNegative, avgPositive,
                    `IPCA during crashes (${avgNegative.toFixed(4)}) should be higher than during booms (${avgPositive.toFixed(4)})`);
            });
        });

        // ============================================
        // 5. DYNAMIC CORRELATION
        // ============================================

        tf.describe('Dynamic FX Correlation', () => {
            tf.it('should return base correlation when dynamic correlation is disabled', () => {
                const params = {
                    ...getDefaultParams(),
                    useDynamicCorrelation: false,
                    baseCorrelation: -0.4
                };
                const engine = new MonteCarloEngine(params);

                const correlation = engine.getDynamicCorrelation(-0.30);  // Stress scenario
                assertEqual(correlation, -0.4, 'Should return base correlation');
            });

            tf.it('should return base correlation for normal market conditions', () => {
                const params = {
                    ...getDefaultParams(),
                    useDynamicCorrelation: true,
                    baseCorrelation: -0.4,
                    stressCorrelationMultiplier: 2.0,
                    equityReturn: 7,
                    equityVolatility: 18
                };
                const engine = new MonteCarloEngine(params);

                // Normal return: within 1 std dev of mean
                const normalReturn = 0.07;  // Exactly at mean
                const correlation = engine.getDynamicCorrelation(normalReturn);

                assertEqual(correlation, -0.4, `Correlation should be base value for normal conditions`);
            });

            tf.it('should increase correlation magnitude during stress (large negative returns)', () => {
                const params = {
                    ...getDefaultParams(),
                    useDynamicCorrelation: true,
                    baseCorrelation: -0.4,
                    stressCorrelationMultiplier: 2.0,
                    equityReturn: 7,
                    equityVolatility: 18
                };
                const engine = new MonteCarloEngine(params);

                // Stress: equity return is 2 std devs below mean (-0.29)
                const stressReturn = 0.07 - 2 * 0.18;  // -0.29
                const correlation = engine.getDynamicCorrelation(stressReturn);

                assertLessThan(correlation, -0.4,
                    `Correlation should be more negative during stress: got ${correlation}`);
            });

            tf.it('should decrease correlation magnitude during boom (large positive returns)', () => {
                const params = {
                    ...getDefaultParams(),
                    useDynamicCorrelation: true,
                    baseCorrelation: -0.4,
                    stressCorrelationMultiplier: 2.0,
                    equityReturn: 7,
                    equityVolatility: 18
                };
                const engine = new MonteCarloEngine(params);

                // Boom: equity return is 2 std devs above mean (0.43)
                const boomReturn = 0.07 + 2 * 0.18;  // 0.43
                const correlation = engine.getDynamicCorrelation(boomReturn);

                assertGreaterThan(correlation, -0.4,
                    `Correlation should be weaker (closer to 0) during boom: got ${correlation}`);
            });

            tf.it('should cap correlation at -0.9 during extreme stress', () => {
                const params = {
                    ...getDefaultParams(),
                    useDynamicCorrelation: true,
                    baseCorrelation: -0.4,
                    stressCorrelationMultiplier: 3.0,
                    equityReturn: 7,
                    equityVolatility: 18
                };
                const engine = new MonteCarloEngine(params);

                // Extreme stress
                const extremeReturn = -0.50;
                const correlation = engine.getDynamicCorrelation(extremeReturn);

                assert(correlation >= -0.9, `Correlation should be capped at -0.9, got ${correlation}`);
            });
        });

        // ============================================
        // 6. BOND RETURN MODEL
        // ============================================

        tf.describe('Bond Return Model', () => {
            tf.it('should use IPCA + Real Spread when IPCA model is enabled', () => {
                const params = {
                    ...getDefaultParams(),
                    useIPCAModel: true,
                    realSpread: 5.5
                };
                const engine = new MonteCarloEngine(params);

                const ipca = 0.045;  // 4.5%
                const samples = [];
                for (let i = 0; i < 1000; i++) {
                    samples.push(engine.generateBondReturn(ipca));
                }

                const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
                const expectedMean = ipca + 0.055;  // IPCA + real spread

                assertAlmostEqual(mean, expectedMean, 0.02,
                    `Mean bond return should be ~${expectedMean}, got ${mean}`);
            });

            tf.it('should use standard distribution when IPCA model is disabled', () => {
                const params = {
                    ...getDefaultParams(),
                    useIPCAModel: false,
                    bondReturn: 4,
                    bondVolatility: 6
                };
                const engine = new MonteCarloEngine(params);

                const samples = [];
                for (let i = 0; i < 5000; i++) {
                    samples.push(engine.generateBondReturn(0.045));  // IPCA value ignored
                }

                const mean = samples.reduce((a, b) => a + b, 0) / samples.length;

                assertAlmostEqual(mean, 0.04, 0.01,
                    `Mean bond return should be ~0.04, got ${mean}`);
            });
        });

        // ============================================
        // 7. CURRENCY SIMULATION
        // ============================================

        tf.describe('Currency Simulation', () => {
            tf.it('should apply mean reversion toward initial FX', () => {
                const params = {
                    ...getDefaultParams(),
                    initialFX: 5.5,
                    useDynamicCorrelation: false,
                    baseCorrelation: 0
                };
                const engine = new MonteCarloEngine(params);

                // Start with FX above mean
                let fxAbove = 7.0;
                let driftAbove = 0;
                for (let i = 0; i < 1000; i++) {
                    const newFX = engine.simulateCurrency(0.07, fxAbove);
                    driftAbove += (newFX - fxAbove);
                }

                // Start with FX below mean
                let fxBelow = 4.0;
                let driftBelow = 0;
                for (let i = 0; i < 1000; i++) {
                    const newFX = engine.simulateCurrency(0.07, fxBelow);
                    driftBelow += (newFX - fxBelow);
                }

                // Average drift should pull FX toward mean
                assertLessThan(driftAbove / 1000, 0,
                    'FX above mean should have negative drift on average');
                assertGreaterThan(driftBelow / 1000, 0,
                    'FX below mean should have positive drift on average');
            });

            tf.it('should have higher volatility during negative equity returns', () => {
                const params = {
                    ...getDefaultParams(),
                    initialFX: 5.5,
                    useDynamicCorrelation: false,
                    baseCorrelation: 0
                };
                const engine = new MonteCarloEngine(params);

                // Collect FX changes during positive returns
                const positiveChanges = [];
                for (let i = 0; i < 1000; i++) {
                    const newFX = engine.simulateCurrency(0.10, 5.5);  // +10% equity
                    positiveChanges.push(Math.abs(newFX - 5.5));
                }

                // Collect FX changes during negative returns
                const negativeChanges = [];
                for (let i = 0; i < 1000; i++) {
                    const newFX = engine.simulateCurrency(-0.10, 5.5);  // -10% equity
                    negativeChanges.push(Math.abs(newFX - 5.5));
                }

                const avgPositive = positiveChanges.reduce((a, b) => a + b, 0) / positiveChanges.length;
                const avgNegative = negativeChanges.reduce((a, b) => a + b, 0) / negativeChanges.length;

                assertGreaterThan(avgNegative, avgPositive,
                    `FX volatility should be higher during negative returns: neg=${avgNegative.toFixed(4)}, pos=${avgPositive.toFixed(4)}`);
            });
        });

        // ============================================
        // 8. EDGE CASES
        // ============================================

        tf.describe('Edge Cases', () => {
            tf.it('should handle zero portfolio value in Guyton-Klinger', () => {
                const params = { ...getDefaultParams() };
                const engine = new MonteCarloEngine(params);

                // This should not throw, even with division by zero scenario
                try {
                    const result = engine.applyGuytonKlinger(47000, 0, 0.047, 0.05, 0.045);
                    // Current rate = 47000/0 = Infinity, which should trigger preservation
                    assert(true, 'Should not throw');
                } catch (e) {
                    throw new Error('Should handle zero portfolio gracefully');
                }
            });

            tf.it('should handle zero withdrawal in Guyton-Klinger', () => {
                const params = { ...getDefaultParams() };
                const engine = new MonteCarloEngine(params);

                const result = engine.applyGuytonKlinger(0, 1000000, 0.047, 0.05, 0.045);
                assertEqual(result.withdrawal, 0, 'Zero withdrawal should remain zero after inflation');
            });

            tf.it('should handle extreme correlation values', () => {
                const engine = new MonteCarloEngine(getDefaultParams());

                // Test with correlation = 0.99
                const result1 = engine.generateCorrelatedReturns(0.99);
                assert(result1.length === 2, 'Should return two values');
                assert(isFinite(result1[0]) && isFinite(result1[1]), 'Values should be finite');

                // Test with correlation = -0.99
                const result2 = engine.generateCorrelatedReturns(-0.99);
                assert(result2.length === 2, 'Should return two values');
                assert(isFinite(result2[0]) && isFinite(result2[1]), 'Values should be finite');
            });

            tf.it('should handle zero gain ratio in tax calculation', () => {
                const params = { ...getDefaultParams(), useTaxModel: true };
                const engine = new MonteCarloEngine(params);

                const tax = engine.calculateTax(100000, 0, 0.5);
                assertEqual(tax, 0, 'Tax should be 0 with 0% gain ratio');
            });

            tf.it('should handle T-Student with very low degrees of freedom', () => {
                const params = { ...getDefaultParams(), useStudentT: true, degreesOfFreedom: 2 };
                const engine = new MonteCarloEngine(params);

                // Should not throw even with df=2 (undefined variance)
                for (let i = 0; i < 100; i++) {
                    const value = engine.randomStudentT(0, 1, 2);
                    assert(isFinite(value), 'Values should be finite even with low df');
                }
            });
        });

        // ============================================
        // 9. DETERMINISTIC SCENARIO TESTS
        // ============================================

        tf.describe('Deterministic Scenarios', () => {
            tf.it('should trigger preservation rule in sequence of bad years', () => {
                const params = {
                    ...getDefaultParams(),
                    preservationThreshold: 0.2,
                    adjustmentPercent: 0.1
                };
                const engine = new MonteCarloEngine(params);

                let portfolio = 1000000;
                let withdrawal = 47000;  // 4.7%
                const initialRate = 0.047;

                // Simulate 3 years of -20% returns
                for (let year = 0; year < 3; year++) {
                    portfolio *= 0.80;  // -20% return
                    portfolio -= withdrawal;

                    const currentRate = withdrawal / portfolio;
                    if (currentRate > initialRate * 1.2) {
                        const result = engine.applyGuytonKlinger(withdrawal, portfolio, initialRate, -0.2, 0);
                        if (result.ruleApplied === 'preservation') {
                            withdrawal = result.withdrawal;
                        }
                    }
                }

                // After severe drops, preservation should have reduced withdrawal
                assertLessThan(withdrawal, 47000,
                    'Withdrawal should be reduced after severe market decline');
            });

            tf.it('should trigger prosperity rule after strong market growth', () => {
                const params = {
                    ...getDefaultParams(),
                    prosperityThreshold: 0.2,
                    adjustmentPercent: 0.1
                };
                const engine = new MonteCarloEngine(params);

                let portfolio = 1000000;
                let withdrawal = 47000;  // 4.7%
                const initialRate = 0.047;

                // Simulate 3 years of +20% returns
                for (let year = 0; year < 3; year++) {
                    portfolio *= 1.20;  // +20% return
                    portfolio -= withdrawal;

                    const result = engine.applyGuytonKlinger(withdrawal, portfolio, initialRate, 0.2, 0.045);
                    if (result.ruleApplied === 'prosperity') {
                        withdrawal = result.withdrawal;
                    }
                }

                // After strong growth, prosperity should have increased withdrawal
                assertGreaterThan(withdrawal, 47000,
                    'Withdrawal should be increased after strong market growth');
            });
        });

        // ============================================
        // 10. SEEDED RNG REPRODUCIBILITY
        // ============================================

        tf.describe('Seeded RNG Reproducibility', () => {
            tf.it('should produce identical sequences with same seed', () => {
                const rng1 = new SeededRNG(12345);
                const rng2 = new SeededRNG(12345);

                for (let i = 0; i < 100; i++) {
                    const v1 = rng1.next();
                    const v2 = rng2.next();
                    assertEqual(v1, v2, `Values should be identical at step ${i}`);
                }
            });

            tf.it('should produce different sequences with different seeds', () => {
                const rng1 = new SeededRNG(12345);
                const rng2 = new SeededRNG(54321);

                let differences = 0;
                for (let i = 0; i < 100; i++) {
                    if (rng1.next() !== rng2.next()) {
                        differences++;
                    }
                }
                assertGreaterThan(differences, 90, 'Most values should differ');
            });

            tf.it('should produce values in [0, 1) range', () => {
                const rng = new SeededRNG(42);
                for (let i = 0; i < 10000; i++) {
                    const v = rng.next();
                    assert(v >= 0 && v < 1, `Value ${v} should be in [0, 1)`);
                }
            });

            tf.it('should generate reproducible normal distributions', () => {
                const params1 = { ...getDefaultParams(), seed: 99999 };
                const params2 = { ...getDefaultParams(), seed: 99999 };
                const engine1 = new MonteCarloEngine(params1);
                const engine2 = new MonteCarloEngine(params2);

                for (let i = 0; i < 50; i++) {
                    const v1 = engine1.randomNormal(0.07, 0.18);
                    const v2 = engine2.randomNormal(0.07, 0.18);
                    assertEqual(v1, v2, `Normal values should be identical at step ${i}`);
                }
            });
        });

        // ============================================
        // 11. G-K MUTUAL EXCLUSIVITY
        // ============================================

        tf.describe('Guyton-Klinger Mutual Exclusivity', () => {
            tf.it('should never apply both preservation AND prosperity in same year', () => {
                const params = {
                    ...getDefaultParams(),
                    preservationThreshold: 0.2,
                    prosperityThreshold: 0.2,
                    adjustmentPercent: 0.1,
                    applyInflationRule: false
                };
                const engine = new MonteCarloEngine(params);

                // Test a range of portfolio values
                const testCases = [
                    { portfolio: 500000, withdrawal: 50000 },   // High rate
                    { portfolio: 2000000, withdrawal: 50000 },  // Low rate
                    { portfolio: 1000000, withdrawal: 47000 },  // Normal rate
                    { portfolio: 750000, withdrawal: 60000 },   // Preservation territory
                    { portfolio: 1500000, withdrawal: 30000 },  // Prosperity territory
                ];

                for (const tc of testCases) {
                    const result = engine.applyGuytonKlinger(tc.withdrawal, tc.portfolio, 0.047, 0.05, 0.03);

                    // Can't be both
                    assert(
                        !(result.ruleApplied === 'preservation' && result.ruleApplied === 'prosperity'),
                        'Should never apply both rules'
                    );
                }
            });

            tf.it('should apply preservation rule first when both thresholds could apply (edge case)', () => {
                // This tests a hypothetical edge case where someone sets overlapping thresholds
                const params = {
                    ...getDefaultParams(),
                    preservationThreshold: 0.5,   // 50% above triggers preservation
                    prosperityThreshold: 0.5,     // 50% below triggers prosperity
                    adjustmentPercent: 0.1,
                    applyInflationRule: false
                };
                const engine = new MonteCarloEngine(params);

                // Rate = 7% (above 4.7% * 1.5 = 7.05%? No, just below)
                // Actually 7% / 4.7% = 1.49, so NOT above 1.5
                // But 7% is way above prosperity threshold (4.7% * 0.5 = 2.35%)
                // So neither should apply at 7%

                const result = engine.applyGuytonKlinger(70000, 1000000, 0.047, 0.05, 0);
                // 7% rate, initial rate 4.7%, preservation threshold is 4.7*1.5=7.05%
                // 7% < 7.05%, so preservation should NOT apply
                // 7% > 2.35%, so prosperity should NOT apply either
                assert(result.ruleApplied === null, 'Neither rule should apply');
            });
        });

        // ============================================
        // 12. END-TO-END REGRESSION TESTS (Seeded)
        // ============================================

        tf.describe('E2E Regression: Portfolio Survival', () => {
            // These tests use fixed seeds to ensure deterministic behavior
            // They should fail if core logic changes unintentionally

            tf.it('REGRESSION: Seed 42 with conservative params should survive', () => {
                const params = {
                    ...getDefaultParams(),
                    seed: 42,
                    initialPortfolioUSD: 1000000,
                    withdrawalRate: 3.5,  // Conservative
                    equityReturn: 7,
                    equityVolatility: 18,
                    bondReturn: 4,
                    bondVolatility: 6,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };
                const engine = new MonteCarloEngine(params);

                let portfolio = params.initialPortfolioUSD;
                let withdrawal = portfolio * (params.withdrawalRate / 100);
                const initialRate = params.withdrawalRate / 100;

                for (let year = 0; year < params.years; year++) {
                    // Generate return
                    const equityReturn = engine.generateReturn(params.equityReturn / 100, params.equityVolatility / 100);
                    const bondReturn = engine.generateReturn(params.bondReturn / 100, params.bondVolatility / 100);

                    // Simple 60/40 portfolio return
                    const portfolioReturn = 0.6 * equityReturn + 0.4 * bondReturn;

                    // Apply return, then withdraw
                    portfolio *= (1 + portfolioReturn);
                    portfolio -= withdrawal;

                    // Apply G-K
                    const gk = engine.applyGuytonKlinger(withdrawal, portfolio, initialRate, portfolioReturn, 0.045);
                    withdrawal = gk.withdrawal;

                    if (portfolio <= 0) break;
                }

                assertGreaterThan(portfolio, 0, `Portfolio should survive 30 years with seed 42 and conservative params (final: ${portfolio.toFixed(0)})`);
            });

            tf.it('REGRESSION: Seed 42 generates consistent returns across runs', () => {
                // Run twice with same seed and verify identical results
                const params1 = { ...getDefaultParams(), seed: 42, useStudentT: false };
                const params2 = { ...getDefaultParams(), seed: 42, useStudentT: false };
                const engine1 = new MonteCarloEngine(params1);
                const engine2 = new MonteCarloEngine(params2);

                // Generate 10 returns from each engine
                const returns1 = [];
                const returns2 = [];
                for (let i = 0; i < 10; i++) {
                    returns1.push(engine1.randomNormal(0.07, 0.18));
                    returns2.push(engine2.randomNormal(0.07, 0.18));
                }

                // Verify they're identical
                for (let i = 0; i < 10; i++) {
                    assertEqual(returns1[i], returns2[i], `Return ${i} should be identical across runs`);
                }

                // Also verify first value is deterministic (lock in actual value)
                const engine3 = new MonteCarloEngine({ ...getDefaultParams(), seed: 42, useStudentT: false });
                const firstReturn = engine3.randomNormal(0.07, 0.18);
                assertAlmostEqual(firstReturn, returns1[0], 0.0001, 'First return should match');
            });
        });

        tf.describe('E2E Regression: Withdrawal Path Stability', () => {
            tf.it('REGRESSION: Withdrawal sequence should be deterministic with seed', () => {
                const params = {
                    ...getDefaultParams(),
                    seed: 777,
                    initialPortfolioUSD: 1000000,
                    withdrawalRate: 4.7,
                    years: 10,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false,
                    applyInflationRule: true
                };

                // Run simulation twice with same seed
                const withdrawals1 = [];
                const withdrawals2 = [];

                for (let run = 0; run < 2; run++) {
                    const engine = new MonteCarloEngine({ ...params, seed: 777 });
                    let portfolio = params.initialPortfolioUSD;
                    let withdrawal = portfolio * (params.withdrawalRate / 100);
                    const initialRate = params.withdrawalRate / 100;
                    const withdrawals = run === 0 ? withdrawals1 : withdrawals2;

                    for (let year = 0; year < params.years; year++) {
                        const equityReturn = engine.generateReturn(0.07, 0.18);
                        const bondReturn = engine.generateReturn(0.04, 0.06);
                        const portfolioReturn = 0.6 * equityReturn + 0.4 * bondReturn;

                        portfolio *= (1 + portfolioReturn);
                        portfolio -= withdrawal;

                        const gk = engine.applyGuytonKlinger(withdrawal, Math.max(portfolio, 1), initialRate, portfolioReturn, 0.045);
                        withdrawal = gk.withdrawal;
                        withdrawals.push(withdrawal);

                        if (portfolio <= 0) break;
                    }
                }

                // Verify both runs produced identical withdrawals
                assertEqual(withdrawals1.length, withdrawals2.length, 'Should have same number of withdrawals');
                for (let i = 0; i < withdrawals1.length; i++) {
                    assertEqual(withdrawals1[i], withdrawals2[i], `Withdrawal ${i} should be identical`);
                }
            });
        });

        tf.describe('E2E Regression: Expected Failure Under Stress', () => {
            tf.it('REGRESSION: Extreme withdrawal rate without G-K should fail (15% SWR)', () => {
                // Test WITHOUT G-K rules - fixed withdrawals that don't adjust
                // 15% SWR with no adjustment should definitely fail
                const params = {
                    ...getDefaultParams(),
                    seed: 123,
                    initialPortfolioUSD: 1000000,
                    withdrawalRate: 15,  // Very extreme - should fail without G-K protection
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };
                const engine = new MonteCarloEngine(params);

                let portfolio = params.initialPortfolioUSD;
                // Fixed withdrawal - NO G-K adjustment (simulating fixed withdrawal strategy)
                const fixedWithdrawal = portfolio * (params.withdrawalRate / 100);
                let failed = false;

                for (let year = 0; year < params.years; year++) {
                    const equityReturn = engine.generateReturn(0.07, 0.18);
                    const bondReturn = engine.generateReturn(0.04, 0.06);
                    const portfolioReturn = 0.6 * equityReturn + 0.4 * bondReturn;

                    portfolio *= (1 + portfolioReturn);
                    portfolio -= fixedWithdrawal;  // Fixed, not adjusted

                    if (portfolio <= 0) {
                        failed = true;
                        break;
                    }
                }

                assert(failed, 'Portfolio with 15% fixed SWR (no G-K) should fail within 30 years');
            });

            tf.it('REGRESSION: Zero equity return environment should struggle', () => {
                const params = {
                    ...getDefaultParams(),
                    seed: 456,
                    initialPortfolioUSD: 1000000,
                    withdrawalRate: 5,
                    equityReturn: 0,  // Zero expected return
                    bondReturn: 2,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };
                const engine = new MonteCarloEngine(params);

                let portfolio = params.initialPortfolioUSD;
                let withdrawal = portfolio * (params.withdrawalRate / 100);
                const initialRate = params.withdrawalRate / 100;

                for (let year = 0; year < params.years; year++) {
                    const equityReturn = engine.generateReturn(0, 0.18);  // 0% mean
                    const bondReturn = engine.generateReturn(0.02, 0.06);
                    const portfolioReturn = 0.6 * equityReturn + 0.4 * bondReturn;

                    portfolio *= (1 + portfolioReturn);
                    portfolio -= withdrawal;

                    if (portfolio <= 0) {
                        // Expected to fail - this is the test passing
                        assert(true, 'Portfolio depleted as expected');
                        return;
                    }

                    const gk = engine.applyGuytonKlinger(withdrawal, portfolio, initialRate, portfolioReturn, 0.045);
                    withdrawal = gk.withdrawal;
                }

                // If we survived, portfolio should be very low
                assertLessThan(portfolio, 500000, 'Portfolio should be significantly depleted in zero-return environment');
            });
        });

        // ============================================
        // 13. OPTIMIZER: BISECTION LOGIC
        // ============================================

        // Simplified Monte Carlo for optimizer tests
        // Tests the bisection concept without the full simulation complexity
        function simplifiedMonteCarlo(params, iterations) {
            const engine = new MonteCarloEngine(params);
            const swr = params.withdrawalRate / 100;
            let survived = 0;
            const finalPortfolios = [];

            for (let i = 0; i < iterations; i++) {
                let portfolio = params.initialPortfolioUSD;
                let withdrawal = portfolio * swr;
                const initialRate = swr;
                let failed = false;

                for (let year = 0; year < params.years; year++) {
                    const equityReturn = engine.generateReturn(
                        params.equityReturn / 100, params.equityVolatility / 100
                    );
                    const bondReturn = engine.generateReturn(
                        params.bondReturn / 100, params.bondVolatility / 100
                    );
                    const bondAlloc = params.tentInitialBondPercent / 100;
                    const portfolioReturn = (1 - bondAlloc) * equityReturn + bondAlloc * bondReturn;

                    portfolio *= (1 + portfolioReturn);
                    portfolio -= withdrawal;

                    if (portfolio <= 0) {
                        failed = true;
                        break;
                    }

                    const gk = engine.applyGuytonKlinger(
                        withdrawal, portfolio, initialRate, portfolioReturn,
                        params.inflation / 100
                    );
                    withdrawal = gk.withdrawal;
                }

                if (!failed) survived++;
                finalPortfolios.push(Math.max(0, portfolio));
            }

            finalPortfolios.sort((a, b) => a - b);
            return {
                survivalRate: (survived / iterations) * 100,
                medianFinalPortfolio: finalPortfolios[Math.floor(iterations / 2)]
            };
        }

        // Two-phase bisection (mirrors index.html implementation)
        function findOptimalSWR(baseParams, targetRate, tolerance, iterations) {
            const masterSeed = baseParams.seed || 42;

            let minSWR = 0.5;
            let maxSWR = 15.0;
            let bestSWR = minSWR;
            let totalSteps = 0;

            // Phase 1: Coarse
            const phase1Tolerance = 0.5;
            while ((maxSWR - minSWR) > phase1Tolerance) {
                const midSWR = (minSWR + maxSWR) / 2;
                const result = simplifiedMonteCarlo(
                    { ...baseParams, withdrawalRate: midSWR, seed: masterSeed },
                    200
                );
                totalSteps++;
                if (result.survivalRate >= targetRate) {
                    bestSWR = midSWR;
                    minSWR = midSWR;
                } else {
                    maxSWR = midSWR;
                }
            }

            // Phase 2: Fine
            minSWR = Math.max(0.5, bestSWR - 1.0);
            maxSWR = Math.min(15.0, bestSWR + 1.0);

            while ((maxSWR - minSWR) > tolerance) {
                const midSWR = (minSWR + maxSWR) / 2;
                const result = simplifiedMonteCarlo(
                    { ...baseParams, withdrawalRate: midSWR, seed: masterSeed },
                    iterations
                );
                totalSteps++;
                if (result.survivalRate >= targetRate) {
                    bestSWR = midSWR;
                    minSWR = midSWR;
                } else {
                    maxSWR = midSWR;
                }
            }

            // Final validation
            const finalResult = simplifiedMonteCarlo(
                { ...baseParams, withdrawalRate: bestSWR, seed: masterSeed },
                iterations
            );

            return {
                optimalSWR: bestSWR,
                survivalRate: finalResult.survivalRate,
                medianFinalPortfolio: finalResult.medianFinalPortfolio,
                totalSteps,
                masterSeed
            };
        }

        tf.describe('Optimizer: Monotonicity (Higher SWR â†’ Lower Survival)', () => {
            tf.it('should show decreasing survival rate as SWR increases', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    seed: 42,
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };

                const rates = [2, 4, 6, 8, 10];
                const survivals = rates.map(swr => {
                    const result = simplifiedMonteCarlo(
                        { ...baseParams, withdrawalRate: swr },
                        300
                    );
                    return result.survivalRate;
                });

                // Each higher SWR should have equal or lower survival
                for (let i = 1; i < survivals.length; i++) {
                    assert(
                        survivals[i] <= survivals[i - 1] + 5, // +5% tolerance for stochastic noise
                        `SWR ${rates[i]}% survival (${survivals[i].toFixed(1)}%) should be â‰¤ SWR ${rates[i-1]}% survival (${survivals[i-1].toFixed(1)}%)`
                    );
                }
            });

            tf.it('should show ~100% survival at very low SWR (2%)', () => {
                const result = simplifiedMonteCarlo({
                    ...getDefaultParams(),
                    seed: 42,
                    withdrawalRate: 2,
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                }, 300);

                assertGreaterThan(result.survivalRate, 95,
                    `2% SWR should have >95% survival, got ${result.survivalRate.toFixed(1)}%`);
            });

            tf.it('should show low survival at very high SWR (12%)', () => {
                const result = simplifiedMonteCarlo({
                    ...getDefaultParams(),
                    seed: 42,
                    withdrawalRate: 12,
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                }, 300);

                assertLessThan(result.survivalRate, 50,
                    `12% SWR should have <50% survival, got ${result.survivalRate.toFixed(1)}%`);
            });
        });

        tf.describe('Optimizer: Bisection Convergence', () => {
            tf.it('should find a valid rate that meets target success rate', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    seed: 42,
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };

                const result = findOptimalSWR(baseParams, 90, 0.2, 500);

                assertGreaterThan(result.optimalSWR, 0.5,
                    `Optimal SWR should be > 0.5%, got ${result.optimalSWR.toFixed(2)}%`);
                assertLessThan(result.optimalSWR, 15,
                    `Optimal SWR should be < 15%, got ${result.optimalSWR.toFixed(2)}%`);
                assertGreaterThan(result.survivalRate, 85,
                    `Survival at optimal SWR should be â‰¥ ~90%, got ${result.survivalRate.toFixed(1)}%`);
            });

            tf.it('should converge within reasonable number of steps', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    seed: 42,
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };

                const result = findOptimalSWR(baseParams, 90, 0.2, 300);

                // Should converge in ~12 steps max (5 coarse + 4-7 fine)
                assertLessThan(result.totalSteps, 15,
                    `Should converge in <15 steps, took ${result.totalSteps}`);
            });

            tf.it('should find higher SWR for lower target success rate', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    seed: 42,
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };

                const result80 = findOptimalSWR(baseParams, 80, 0.3, 300);
                const result95 = findOptimalSWR(baseParams, 95, 0.3, 300);

                assertGreaterThan(result80.optimalSWR, result95.optimalSWR,
                    `80% target SWR (${result80.optimalSWR.toFixed(2)}%) should be > 95% target (${result95.optimalSWR.toFixed(2)}%)`);
            });
        });

        tf.describe('Optimizer: Reproducibility with Seeds', () => {
            tf.it('should produce identical results with same seed', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    seed: 777,
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };

                const result1 = findOptimalSWR(baseParams, 90, 0.2, 300);
                const result2 = findOptimalSWR(baseParams, 90, 0.2, 300);

                assertEqual(result1.optimalSWR, result2.optimalSWR,
                    `Same seed should produce same optimal SWR: ${result1.optimalSWR} vs ${result2.optimalSWR}`);
            });

            tf.it('should produce different results with different seeds', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };

                const result1 = findOptimalSWR({ ...baseParams, seed: 111 }, 90, 0.2, 300);
                const result2 = findOptimalSWR({ ...baseParams, seed: 999 }, 90, 0.2, 300);

                // Results may differ slightly due to different random sequences
                // They don't need to be very different, just not guaranteed to be identical
                // This is a soft check - the key is that seeds are deterministic
                assert(true, 'Different seeds may produce different results');
            });
        });

        tf.describe('Optimizer: Edge Cases', () => {
            tf.it('should handle very high target success rate (99%)', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    seed: 42,
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };

                const result = findOptimalSWR(baseParams, 99, 0.3, 1000);

                // At 99% target, SWR should be quite conservative
                assertLessThan(result.optimalSWR, 6,
                    `99% target should yield conservative SWR (<6%), got ${result.optimalSWR.toFixed(2)}%`);
                assertGreaterThan(result.optimalSWR, 0.5,
                    `Should still find a valid SWR > 0.5%`);
            });

            tf.it('should handle short horizon (10 years)', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    seed: 42,
                    initialPortfolioUSD: 1000000,
                    years: 10,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };

                const result = findOptimalSWR(baseParams, 90, 0.3, 300);

                // Short horizon should allow higher SWR
                assertGreaterThan(result.optimalSWR, 5,
                    `10-year horizon should allow higher SWR (>5%), got ${result.optimalSWR.toFixed(2)}%`);
            });

            tf.it('should handle long horizon (50 years)', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    seed: 42,
                    initialPortfolioUSD: 1000000,
                    years: 50,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false
                };

                const result = findOptimalSWR(baseParams, 90, 0.3, 300);

                // Long horizon should require lower SWR
                assertLessThan(result.optimalSWR, 8,
                    `50-year horizon should require lower SWR, got ${result.optimalSWR.toFixed(2)}%`);
            });
        });

        tf.describe('Optimizer: G-K Rules Impact', () => {
            tf.it('should find higher optimal SWR with G-K rules vs without', () => {
                const baseParams = {
                    ...getDefaultParams(),
                    seed: 42,
                    initialPortfolioUSD: 1000000,
                    years: 30,
                    useStudentT: false,
                    useDynamicCorrelation: false,
                    useIPCAModel: false,
                    useTaxModel: false,
                    applyInflationRule: true,
                    preservationThreshold: 0.2,
                    prosperityThreshold: 0.2,
                    adjustmentPercent: 0.1
                };

                // With G-K rules (adjustmentPercent > 0)
                const resultWithGK = findOptimalSWR(baseParams, 90, 0.3, 300);

                // Without G-K adjustment (adjustmentPercent = 0 effectively disables)
                const resultNoGK = findOptimalSWR(
                    { ...baseParams, adjustmentPercent: 0, applyInflationRule: false },
                    90, 0.3, 300
                );

                // G-K rules should allow higher SWR since they protect the portfolio
                assertGreaterThan(resultWithGK.optimalSWR, resultNoGK.optimalSWR - 0.5,
                    `G-K should allow â‰¥ similar SWR: with=${resultWithGK.optimalSWR.toFixed(2)}% vs without=${resultNoGK.optimalSWR.toFixed(2)}%`);
            });
        });

        // ============================================
        // RUN TESTS
        // ============================================

        async function runAllTests() {
            const button = document.querySelector('.run-button');
            const progressDiv = document.getElementById('progress');
            const resultsDiv = document.getElementById('results');
            const summaryDiv = document.getElementById('summary');

            button.disabled = true;
            resultsDiv.innerHTML = '';
            summaryDiv.style.display = 'none';

            await tf.runAll((msg) => {
                progressDiv.textContent = msg;
            });

            progressDiv.textContent = 'Tests completed!';

            // Display results by suite
            const suites = tf.getResultsBySuite();
            for (const [suiteName, tests] of Object.entries(suites)) {
                const suiteDiv = document.createElement('div');
                suiteDiv.className = 'test-suite';
                suiteDiv.innerHTML = `<h2>${suiteName}</h2>`;

                for (const test of tests) {
                    const testDiv = document.createElement('div');
                    testDiv.className = `test-result ${test.passed ? 'pass' : 'fail'}`;
                    testDiv.innerHTML = `${test.passed ? 'âœ“' : 'âœ—'} ${test.name}`;

                    if (!test.passed && test.error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'error-details';
                        errorDiv.textContent = test.error;
                        testDiv.appendChild(errorDiv);
                    }

                    suiteDiv.appendChild(testDiv);
                }

                resultsDiv.appendChild(suiteDiv);
            }

            // Display summary
            const summary = tf.getSummary();
            summaryDiv.innerHTML = `
                <div class="summary-item">
                    <div class="summary-number total-count">${summary.total}</div>
                    <div class="summary-label">Total Tests</div>
                </div>
                <div class="summary-item">
                    <div class="summary-number pass-rate">${summary.passed}</div>
                    <div class="summary-label">Passed</div>
                </div>
                <div class="summary-item">
                    <div class="summary-number fail-count">${summary.failed}</div>
                    <div class="summary-label">Failed</div>
                </div>
                <div class="summary-item">
                    <div class="summary-number ${summary.failed === 0 ? 'pass-rate' : 'fail-count'}">${summary.rate}%</div>
                    <div class="summary-label">Pass Rate</div>
                </div>
            `;
            summaryDiv.style.display = 'flex';

            button.disabled = false;
        }
    </script>
</body>
</html>
